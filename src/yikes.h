K values(K x);
K0 empty_atom(K x);
K0 null_type_K0(K x);
K null_type(K x);
I is_null_atom(K x);
K1 denest_K1_from_start_and_key(K start_map,K key_charvec,bool creates,bool treelike);
K0 kat(K x,K y,bool creates_maps,bool throws_errors);
K simple_at(K x,K y);
K simple_at_creates(K x,K y,bool creates_maps);
K table_integral_at(K x,K y);
K atlas_integral_at(K x,K y);
K at(K x,K y);
K of(K x,K y);
K of_i_w(K x,K y,I k,K w,bool denest_charvec);
K alter(K w,K x,K y,K z);
K change(K target,K indices,K modifier,K supplies);
K cow_change(K parent,K key,K indices,K modifier,K supplies,bool demotes);
K cow_change_i(K parent,K key,K indices,K modifier,K supplies,I deep,bool demotes);
K cow_change_at(K parent,K key,K indices,K modifier,K supplies,bool demotes);
K cow_change_at_no_overhead(K parent,K key,K indices,K modifier,K supplies);
K update(K target,K index,K replacement);
K update_ri_rd(K target,K index,K replacement,bool increment,bool decrement);
I indexify(K x);
int kerf_api_init();
void kerf_api_release(K x);
K kerf_api_retain(K x);
K kerf_api_copy_on_write(K x);
K kerf_api_new_kerf(C t,I n);
K kerf_api_new_int(I n);
K kerf_api_new_float(F n);
K kerf_api_new_stamp(I n);
K kerf_api_new_charvec(char *str);
K kerf_api_new_map();
K kerf_api_new_list();
K kerf_api_nil();
K kerf_api_show(K x);
I kerf_api_len(K x);
I kerf_api_nanos_from_stamp(void *x);
K kerf_api_get(K x,K index);
K kerf_api_set(K x,K index,K replacement);
K kerf_api_append(K x,K y);
K kerf_api_interpret(K str);
K kerf_api_call_nilad(K func);
K kerf_api_call_monad(K func,K x);
K kerf_api_call_dyad(K func,K x,K y);
void kerf_api_register_for_eventing(void **p_kerf_hook,int(*p_func)(void *));
void kerf_api_register_for_eventing(void **p_kerf_hook,int(*p_func)(void *));
void kerf_api_deregister_for_eventing(void *kerf_hook);
void kerf_api_deregister_for_eventing(void *kerf_hook);
void kerf_api_notify_event(void *kerf_hook);
void kerf_api_denotify_event(void *kerf_hook);
extern int virtual_memory_blocks[MAPPED_BLOCKS];
extern I MAPPED_BLOCK_SIZE;
extern V MAPPED_ORIGIN;
extern I PAGE_SIZE_BYTES;
extern char POOL_LANE_STRUCT_MIN;
extern char POOL_LANE_MAX;
extern char DISK_LANE_MIN;
extern __kerfthread void *POOL[POOL_LANE_BUF];
extern I The_Holding_Temphandle;
V mmap_place_on_hold(void *start,I bytes);
I memory_init();
I2 widest_block_sequence();
I2 block_window_at(V p);
void mark_block_sequence(I2 sequence,int mark);
I count_occupied_virtual_memory_blocks();
void show_virtual_memory_blocks();
I total_cores();
I total_physical_system_memory_bytes();
char ceiling_log_2(unsigned long long v);
char floor_log_2(unsigned long long v);
char is_power_of_2(I v);
I __attribute__((hot))round_up_nearest_power_of_2(I v);
I __attribute__((pure))round_up_nearest_multiple_of_8(I v);
void inspect_pool();
void *pool_anonymous_system_memory(I requested_bytes,bool shared);
void *pool_depool(char lane);
void pool_repool(void *v,char lane);
char min_lane_for_bytes(I bytes_requested,char min_lane);
void *pool_alloc_with_min_lane(I bytes_requested,char min_lane);
void *pool_alloc_struct(I bytes_requested);
void pool_dealloc(void *z);
K Kb(C c);
K Kc(C c);
K Ki(I i);
K Kf(F f);
K Ks(I i);
K Kn();
K Kk();
K charvec_from_cnstring(S s,I n);
K charvec_from_cstring(S s);
K new_subarray(K x,I start,I end);
K new_map();
K new_hashset();
K new_intern();
K new_btree();
K new_table();
K new_database();
K new_zip();
C zip_attr_for_subtype(C t);
K new_zip_for_subtype(C t);
K new_k(C t,I n);
K kprep(K x,C t,I n);
I list_size_k(C t,I n);
C list_size_m(C t,I n);
I box_count_K(K x);
I any_size_K(K x);
ALWAYS_INLINE I total_space_K(K x);
ALWAYS_INLINE I max_possible_count_K(K x);
I derived_height(K x);
I derived_height_I(K x);
V list_payload_start(K x);
I list_payload_length(K x);
K fill_list_payload_I(K x,I a);
K zero_list_payload(K x);
K zero_unused_space(K x);
I last_jump_index(K x);
K last_jump_start(K x);
V nest_index_used_end(K x);
V nest_index_space_end(K x);
V nest_payload_start(K x);
V nest_payload_end(K x);
I nest_payload_total_space(K x);
I nest_payload_used(K x);
I nest_payload_remaining(K x);
I non_empty_count(K x);
I empty_count(K x);
void pool_assertions();
void pool_init();
int pool_go();
K strong(K x);
void rd(K x);
void decrement_subelements(K x);
void _rd_function_helper(K x);
K cow_compiled_ref_increment_map(K x);
K cow_compiled_ref_split_map(K x);
K1 compiled_var_path_increment(K x,K y);
void compiled_ref_decrement_path_in_map(K map,K y);
K cow(K x);
K cow0(K x);
K copy(K x);
K copy_override(K x);
K copy_m(K x,I m_min,I zero_new,bool allow_mmap_master_copy);
K compiled_ref_safe_copy_map(K x);
K _expand_in_memory_struct(K x,I m_requested,I zero_new);
K expand_zero(K x,I m_requested,I zero_new);
K expand(K x,I m_requested);
K nestneu(K x,I i,K y);
void nestset(K z,I i,K y);
void nestset_ri_rd(K z,I i,K y,I increment,I decrement);
void _disk_nestset(K z,I i,K y);
K cow_sort(K x);
K cow_coerce_vlist(K x);
K cow_coerce_array(K x);
K cow_coerce_column(K x);
K cow_join(K x,K y);
K cow_expand_zero(K x,I m,I zero_new);
K cow_expand(K x,I m);
K cow_add_funny(K x,K y);
K cow_add(K x,K y);
K cow_delete(K x,K y);
K cow_delete_keys(K x,K y);
K in_place_delete_keys(K x,K y);
K cow_delete_indices(K x,K y);
K cow_demote(K x);
K cow_special_promote(K x);
K cow_promote(K x);
K cow_ensure_null_terminated_chars(K x);
ALWAYS_INLINE bool check_attr_sort_at_i(K x,I i);
ALWAYS_INLINE bool check_attr_sort_at_last_item(K x);
ALWAYS_INLINE bool check_attr_sort_for_join(K x,K y);
extern __kerfthread VM0 KVM0;
extern __kerfthread VM KVM;
extern bool The_Emu_Debug_Flag;
int vm_init();
int local_vm_init(VM *a);
void vm_dealloc(VM m);
void vm_reset(VM m);
I read_log_2_n_bytes_as_integer(VM m,I g);
K0 log_2_n_bytes_from_integer(I i);
I read_compressed_integer(VM m);
I read_uncompressed_integer(VM m);
I read_byte(VM m);
void ensure_stack_height_absolute(VM m,I n);
void ensure_stack_height_relative(VM m,I n);
void pop(VM m);
void push_ri(VM m,K x,I increment);
K *work_push(K x);
K work_pop_rd(bool decrement);
K work_pop_expect(K expecting);
K work_pop();
K work_pop_n(I n);
K work_pop_n_rd(I n,bool decrement);
I frame_height(VM m);
void frame_open(VM m);
void frame_close(VM m);
void function_apply(VM m);
void function_open(VM m);
void function_push_derived_args_to_start(VM m);
void function_go(VM m);
void push_arglocal(VM m,I i);
void function_close(VM m);
void adverb_open(VM m);
void adverb_init_working_valence(VM m);
I adverb_conformable(VM m,I start,I argc);
void adverb_increment_i(VM m);
bool adverb_is_dupe(VM m);
void adverb_init(VM m,I kind);
void adverb_close(VM m);
void recover_from_soft_jmp();
void fully_recover_from_hard_jmp();
int sigsetjmp_protected_ex(VM m,K function);
int local_ex(VM m,K function);
K new_func_closed_from_stack(K function,VM m);
int _local_ex(VM m,K func);
void wrapper_for_return(VM m,I local_ex_floor,bool *done);
extern __kerfthread I last_verb_bytecode_position;
extern __kerfthread K last_verb_function;
K compile(K snippet,K directory);
K compile_with_parent_args(K snippet,K directory,K parent,K args,C function_kind,C alt_attributes);
K assemble(K snippet,K tree,K directory,K parent,K args,C function_kind,C alt_attributes);
K new_func_for_dynamically_loaded_library(K library_name,K library_function_name,C argc,C alt_attributes);
K dlload(K filename,K function_name,K arg_count);
int func_compile_globals_dyload(K func);
K kerf_look(K z,I i);
K kerf_monad_ex(K x,K y);
bool is_global_name_assignment(K x,K function,K parent);
bool is_global_name_constant(K x,K function,K parent);
void func_wipe_compiled_globals_no_decrement(K func);
int recursive_func_compile_globals_after_read(K x,K directory);
int func_compile_globals(K func,K directory);
K func_absolute_longform_globals(K func);
K apply(K function,K list_of_args);
void translate(K tree,K *bytecode,K *debug,K function,K parent,I apply,I argc);
void translate_noun(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control_def(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control_do(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control_while(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control_for(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_control_if(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_assignment(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_name(K tree,K *bytecode,K *debug,K function,K parent);
void translate_direct_name(K tree,K *bytecode,K *debug,K function,K parent,bool creates);
void translate_plain(K tree,K *bytecode,K *debug,K function,K parent);
K reverse(K x);
void translate_bound_args(K tree,K *bytecode,K *debug,K function,K parent,bool reverse);
void add_separator_code(K *bytecode,K *debug,I location);
I2 derived_verb_arity(K tree);
void translate_separation(K tree,K *bytecode,K *debug,K function,K parent);
void translate_paren(K tree,K *bytecode,K *debug,K function,K parent);
void translate_list(K tree,K *bytecode,K *debug,K function,K parent);
void add_list_separator_code(K *bytecode,K *debug,I location);
void translate_curly(K tree,K *bytecode,K *debug,K function,K parent);
void translate_derived_verb(K tree,K *bytecode,K *debug,K function,K parent,I min_args,I max_args,I start,I end);
K parse_lambda_args(K tree);
void translate_function(K tree,K *bytecode,K *debug,K function,K parent);
void translate_table(K tree,K *bytecode,K *debug,K function,K parent);
void translate_atlas(K tree,K *bytecode,K *debug,K function,K parent);
void translate_map(K tree,K *bytecode,K *debug,K function,K parent);
void translate_rel_datetime(K tree,K *bytecode,K *debug,K function,K parent);
void translate_verb(K tree,K *bytecode,K *debug,K function,K parent,I apply,I argc);
void translate_bound(K tree,K *bytecode,K *debug,K function,K parent);
void translate_verbal_nna(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_verbal_nva(K tree,K *bytecode,K *debug,K function,K parent,I apply);
void translate_verbal_na(K payload,K tree,K *bytecode,K *debug,K function,K parent,I apply,I additional_arity);
void translate_verbal_va(K payload,K tree,K *bytecode,K *debug,K function,K parent,I apply,I additional_arity);
void translate_adverb(K token,K *local_bytecode,K *local_debug,K function,K parent,I apply,I min_args,K noun_token);
K wrap_code_adverb(I adverb_kind,K *bytecode,K *debug,K function,K parent,I min_args,K noun_token,I location);
void translate_alike(K tree,K *bytecode,K *debug,K function,K parent);
void translate_reserved(K tree,K *bytecode,K *debug,K function,K parent);
void translate_self(K tree,K *bytecode,K *debug,K function,K parent);
K parse_string(K x);
I translate_string(K tree,K *bytecode,K *debug,K function,K parent);
I translate_backtick(K tree,K *bytecode,K *debug,K function,K parent);
void translate_return(K tree,K *bytecode,K *debug,K function,K parent);
I translate_constant(K *bytecode,K *debug,K function,K found_constant,I debug_location);
void translate_global(K *bytecode,K *debug,K function,K parent,K found_global,I debug_location,bool creates);
void translate_arglocal(K *bytecode,K *debug,K function,K parent,K found_arglocal,I debug_location,bool creates);
void add_code_byte_op_compression(K *bytecode,K *debug,C op,I debug_location,I uncompressed);
void add_code_byte_op_compressed_3(K *bytecode,K *debug,C op,I debug_location,I uncompressed);
void add_code_byte_op_flat(K *bytecode,K *debug,C op,I debug_location,I uncompressed);
void add_code_byte(K *bytecode,K *debug,C code,I debug_location);
int func_go();
ALWAYS_INLINE char FC(F a,F b);
char FC_ulps(F a,F b);
ALWAYS_INLINE char IC(I i,I j);
char SC(S a,S b);
char lexicographic(K x,K y);
char LC(K x,K y);
ALWAYS_INLINE C AC(K x,K y);
char KC_NUM(K x,K y);
char KC(K x,K y);
C matchC(K x,K y,I tolerant);
bool charvec_case_matchC(K x,K y,bool case_insensitive);
K hash_type_compare_pre_whered(K intern,K y,I *original_table);
K hash_type_compare_unwhered_bytes(K x,K y,I *original_table);
K boolean_char_vector_from_true_indices(K indices,I length);
K promote_char_types_to_int_types(K x);
K tri_compare(K x,K y,I *original_table);
K tri_compare_chars(K x,K y,I *original_table);
K tri_compare_optimized(K x,K y,I *original_table);
K tri_compare_pre_whered(K x,K y,I *original_table);
I finder(K x,K y,K column_decoder);
I2 ranger(K x,K y,K column_decoder);
I search_equal_mark_recursive(K x,K y,I low,I high,C style);
I2 search_equal_range(K x,K y);
I2 search_equal_range_within_range(K x,K y,I2 range);
K attr_sort_compare_pre_whered(K x,K y,I *original_table);
K indices_from_n_equal_range_and_comparison_truthtable(I n,I2 equal,I *table);
K charGrade(K x,I r);
K distributionGrade(K x,I r,I u,I v);
UI makeMask(C start,C width);
ALWAYS_INLINE UI wellOrderSignedInt(I i);
ALWAYS_INLINE UI wellOrderSignedFloat(F f);
K digitalGradePass(K x,I updown,K y,K buckets,C kind,C bits,C pass);
K digitalGrade(K x,I r);
ALWAYS_INLINE C table_row_compare(K x,I a,I b);
bool table_is_sorted(K x);
void merger(K x,I r,K u,K v,I s,I t,I m);
void doMergeGrade(K x,I r,K u,K v,I s,I t);
K mergeGrade(K x,I r);
K grade_updown_table(K x,I r);
K grade_updown_hash(K x,I r);
K grade_updown(K x,I r);
K grade_up(K x);
K grade_down(K x);
bool is_sorted_vlist(K x);
bool is_sorted_array(K x);
int grade_go();
void sort_type_indices_via_comparison(K z,K reference_row,I index,I *table,K *places,I parent_to_right_was_equal,I parent_to_left_was_equal,bool atlas_key_required,bool between_override);
K sort_type_compare_pre_whered(K x,K y,I *original_table,bool atlas_key_required,bool between_override);
I sort_find_min_max_value_place(K z,I option);
I2 landis_find_equals_index_child_range(K z,K needle_row);
I landis_find_index_child(K z,I start_child,K needle_row,I equal_behavior,I provided_index,I *stack,I *stack_pointer);
K landis_row_for_place(K z,I place);
K which(K x);
K landis_static_row_for_place(K z,I place,I which);
char landis_row_compare(K p_row,K q_row);
char landis_row_compare_override(K p_row,K q_row,bool between_override);
char landis_compare_rows_place(K z,I p,I q);
ALWAYS_INLINE void SET_LINK(LANDIS_NODE *node,char child,I place);
ALWAYS_INLINE void SET_BALANCE(LANDIS_NODE *n,char balance);
I landis_index_add_node_for_position(K z,I place);
ALWAYS_INLINE void SAFE_STACK_CHILD_SET(K x,I *stack,I k,I value);
void landis_index_delete_node_for_position(K z,I place);
K _alter_tree_single(K x,I k,K y);
K _alter_tree_general(K x,I k,K row);
K cow_sort_add_single(K x,K y);
K cow_sort_add_general(K x,K row);
bool landis_has_row(K z,K needle_row);
bool landis_can_add_row(K x,K y);
K grade_updown_landis_recursive(K z,I descending,I index,K *grades);
K grade_updown_from_landis(K z,I descending);
bool landis_is_sorted(K z);
bool landis_unreachable_place(K z,I place);
bool landis_unreachable_node(K z,I haystack,I needle);
bool landis_nodes_ok(K z,I a,I b);
bool landis_node_balance_ok(K z,I index);
bool landis_balance_ok(K z);
I landis_node_reachable(K z,I index);
I landis_reachable_count(K z);
char landis_node_height(K z,I index);
char landis_height(K z);
char landis_is_sane(K z);
bool test_landis();
bool test_landis_alter();
bool test_landis_deletes();
bool test_landis_preindexing();
K new_btree_from_K(K x);
K new_btree_from_strips(K list);
K cow_landis_reindex(K z);
I landis_index_from_grades_recursive(K z,I link,I low,I high,K grades);
I landis_index_from_grades(K z,K grades);
int run_landis();
K len(K x);
uint64_t fasthash64(const void *buf,size_t len,uint64_t seed);
extern uint64_t HASH_KEY;
void hash_init();
uint64_t hash_bytes(void *in,uint64_t length);
uint64_t hash_byte_stream(void *in,uint64_t length,uint64_t seed);
uint64_t hash_K_stream(K x,uint64_t base);
uint64_t hash(K x);
I lookupI(K map,K key);
K map_lookup(K map,K list);
I find_index_index(K map,uint64_t key_hash,K key,I *probe_distance);
I distance(K map,uint64_t key_hash,I eventual);
void robin_hood_insert(K map,uint64_t key_hash,I key_i,I original_distance);
char map_indexer(K map,I k);
void hash_grow_index(K map);
I insert_replace(K z,K key,K value,I replaces,I hashset);
I insert_replace_ri_rd(K z,K key,K value,I replaces,I hashset,bool increment,bool decrement);
K cow_reindex(K x);
void reindex(K x);
char renameKey(K x,K keyOld,K keyNew);
I fast_invert2(I x,I m,I n);
I fast_invert1(I x,I m,I n);
I lift(I c,I r,I k,I m);
I multilift(I c,I endk,I r);
I hensel(I c,I p);
K new_map_from_K_K(K x,K y,I hashset,I traits);
K cow_intern_add(K x,K y);
K _alter_intern_single(K x,I k,K y);
int hashtable_go();
extern S KERFPROMPT;
extern S KERFCONTINUEPROMPT;
extern MESSAGE1 CONNECTION_POOL[FD_SETSIZE];
extern fd_set fd_master_data_channels;
extern int fd_channel_max;
extern int ipc_socket_listener;
extern int http_socket_listener;
extern int iterating_fd_set_descriptor;
extern C The_Term_Reading_Inited_Once_Flag;
void init_or_reinit_term_reading();
bool reads_term_input();
void select_attend();
bool polled_fd_is_hup_socket(int fd);
char detects_as_socket(int fd);
void kerf_notify_event(void *kerf_hook);
void kerf_denotify_event(void *kerf_hook);
void *get_in_addr(struct sockaddr *sock_address);
void handle_new_server_connection();
void wipe_channel(int i);
void close_channel(int i);
bool msg_header_check(MESSAGE0 m0);
void msg_header_dump(MESSAGE0 m0);
K read_http_channel(int channel_fd);
K read_channel(int channel_fd,int reading_type);
K open_socket(K x,K y);
K close_socket(K x);
void warn_bad_socket();
K send_async_json(K x,K y,K z);
K send_sync_json(K x,K y,K z);
bool use_compressed_payload(K x);
K send_async(K x,K y,K z);
K send_sync(K x,K y,K z);
void bind_socket(S port,int *socket_listener);
void launch_or_relaunch_server();
void special_case_commands(S *s);
void line_handler(char *line);
extern __kerfthread sigjmp_buf *soft_jmp_env;
extern __kerfthread sigjmp_buf *hard_jmp_env;
extern volatile bool canjump;
extern volatile int The_Did_Interrupt_Flag;
pid_t kerf_fork();
int signal_init();
void handle_SIGUSR1(int sig);
int spawn_socket_hup_thread();
void *socket_hup_thread(void *arg);
void handle_SIGINT(int sig);
S error_string(int val);
void reset_lex_parse_globals();
void error_snippet_caret(K text,I position,K *snippet,I *caret);
I error_position(VM m);
K new_error_map_base(int val);
K update_error_with_position_text(K error,I position,K text);
K new_error_map_execution(int val,VM m);
K new_error_map_lexing_parsing(int val,I position,K text);
extern __kerfthread int lex_errno;
extern __kerfthread int lex_errno_location;
extern __kerfthread int parse_errno;
extern __kerfthread int parse_errno_location;
extern S RESERVED_NUMBER_NAMES[];
extern S RESERVED_NAME_NAMES[];
extern S RESERVED_SQL_STARTS[];
extern S RESERVED_SQL_MIDDLES[];
extern S token_names[];
extern C lex_transition_grids[TOKENS_SIZE][MAX_DFA_STATES][256];
extern C parse_transition_grids[TOKEN_GROUP_SIZE][MAX_DFA_STATES][256];
extern C lex_classes[][MAX_DFA_CLASS_SIZE];
extern DFA LEX_DFAS[];
extern C parse_classes[][MAX_DFA_CLASS_SIZE];
extern DFA PARSE_DFAS[];
void reserved_init();
void dfa_populate(DFA dfa_array[],I array_len,C class_maps[][MAX_DFA_CLASS_SIZE]);
void dfa_init();
void lex_init();
K lower(K x);
I reserved_lookup(K x,bool case_insensitive);
K parse_number(K x);
K lex(K snippet);
K toke(K snippet,I start,I *travelled);
K token_bundle(I mark,I start,I end,K payload);
I check_parenthetical_groupings(K tokens);
K parse(K snippet,K tokens);
K scoop_top(K tokens,I top_type,I start,I length,I *top_ran);
K scoop_separator(K tokens,I scoop_type,I start,I length,I *middle_ran);
K flat_pass(K list,I scoop_type);
K token_filter_group_dfas(K input_tokens,I dfas[]);
K drop(K x,K y);
void mine(K tokens,I dfas[],I start,I *travelled,I *mark,I *error,I *drop,I *bundle);
K wrangle(K parent,I start,I length,I drop_inert);
K token_filter_negate_numbers(K tokens);
K token_filter_drop_whitespace_comments(K tokens);
#if !defined(LZ4_COMMONDEFS_ONLY)
int LZ4_versionNumber(void);
int LZ4_compressBound(int isize);
int LZ4_sizeofState();
ALWAYS_INLINE int LZ4_compress_generic(void *const ctx,const char *const source,char *const dest,const int inputSize,const int maxOutputSize,const limitedOutput_directive outputLimited,const tableType_t tableType,const dict_directive dict,const dictIssue_directive dictIssue,const U32 acceleration);
int LZ4_compress_fast_extState(void *state,const char *source,char *dest,int inputSize,int maxOutputSize,int acceleration);
int LZ4_compress_fast(const char *source,char *dest,int inputSize,int maxOutputSize,int acceleration);
int LZ4_compress_default(const char *source,char *dest,int inputSize,int maxOutputSize);
int LZ4_compress_fast_force(const char *source,char *dest,int inputSize,int maxOutputSize,int acceleration);
int LZ4_compress_destSize(const char *src,char *dst,int *srcSizePtr,int targetDstSize);
LZ4_stream_t *LZ4_createStream(void);
void LZ4_resetStream(LZ4_stream_t *LZ4_stream);
int LZ4_freeStream(LZ4_stream_t *LZ4_stream);
int LZ4_loadDict(LZ4_stream_t *LZ4_dict,const char *dictionary,int dictSize);
int LZ4_compress_fast_continue(LZ4_stream_t *LZ4_stream,const char *source,char *dest,int inputSize,int maxOutputSize,int acceleration);
int LZ4_compress_forceExtDict(LZ4_stream_t *LZ4_dict,const char *source,char *dest,int inputSize);
int LZ4_saveDict(LZ4_stream_t *LZ4_dict,char *safeBuffer,int dictSize);
ALWAYS_INLINE int LZ4_decompress_generic(const char *const source,char *const dest,int inputSize,int outputSize,int endOnInput,int partialDecoding,int targetOutputSize,int dict,const BYTE *const lowPrefix,const BYTE *const dictStart,const size_t dictSize);
int LZ4_decompress_safe(const char *source,char *dest,int compressedSize,int maxDecompressedSize);
int LZ4_decompress_safe_partial(const char *source,char *dest,int compressedSize,int targetOutputSize,int maxDecompressedSize);
int LZ4_decompress_fast(const char *source,char *dest,int originalSize);
LZ4_streamDecode_t *LZ4_createStreamDecode(void);
int LZ4_freeStreamDecode(LZ4_streamDecode_t *LZ4_stream);
int LZ4_setStreamDecode(LZ4_streamDecode_t *LZ4_streamDecode,const char *dictionary,int dictSize);
int LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode,const char *source,char *dest,int compressedSize,int maxOutputSize);
int LZ4_decompress_fast_continue(LZ4_streamDecode_t *LZ4_streamDecode,const char *source,char *dest,int originalSize);
ALWAYS_INLINE int LZ4_decompress_usingDict_generic(const char *source,char *dest,int compressedSize,int maxOutputSize,int safe,const char *dictStart,int dictSize);
int LZ4_decompress_safe_usingDict(const char *source,char *dest,int compressedSize,int maxOutputSize,const char *dictStart,int dictSize);
int LZ4_decompress_fast_usingDict(const char *source,char *dest,int originalSize,const char *dictStart,int dictSize);
int LZ4_decompress_safe_forceExtDict(const char *source,char *dest,int compressedSize,int maxOutputSize,const char *dictStart,int dictSize);
int LZ4_compress_limitedOutput(const char *source,char *dest,int inputSize,int maxOutputSize);
int LZ4_compress(const char *source,char *dest,int inputSize);
int LZ4_compress_limitedOutput_withState(void *state,const char *src,char *dst,int srcSize,int dstSize);
int LZ4_compress_withState(void *state,const char *src,char *dst,int srcSize);
int LZ4_compress_limitedOutput_continue(LZ4_stream_t *LZ4_stream,const char *src,char *dst,int srcSize,int maxDstSize);
int LZ4_compress_continue(LZ4_stream_t *LZ4_stream,const char *source,char *dest,int inputSize);
int LZ4_uncompress(const char *source,char *dest,int outputSize);
int LZ4_uncompress_unknownOutputSize(const char *source,char *dest,int isize,int maxOutputSize);
int LZ4_sizeofStreamState();
int LZ4_resetStreamState(void *state,char *inputBuffer);
void *LZ4_create(char *inputBuffer);
char *LZ4_slideInputBuffer(void *LZ4_Data);
int LZ4_decompress_safe_withPrefix64k(const char *source,char *dest,int compressedSize,int maxOutputSize);
int LZ4_decompress_fast_withPrefix64k(const char *source,char *dest,int originalSize);
#endif
extern K gby_hack;
extern I gby_hack_count;
extern char **The_C_Args;
extern C The_History_File[255];
extern I The_Precision;
extern K The_Kerf_Tree;
extern K The_Kerf_Args;
extern K The_Reserved;
extern K The_Allocations;
extern C The_Allocations_Dir[64];
extern C The_Allocations_Path[64];
extern C The_Allocations_Stay_Flag;
extern K The_Cache;
extern C The_Language_Initialized_Flag;
extern C The_Past_The_Test_Suite_Flag;
extern C The_Timing;
extern S The_Kerf_IPC_Port;
extern S The_Kerf_HTTP_Port;
extern C The_Authentication_Required_Flag;
extern S The_Editline_Buffer;
extern C The_Quiet_Flag;
extern C The_Logfile_Flag;
extern K The_Logfile_Object;
extern C The_Intentional_Midstream_Exit_Flag;
extern K The_Print_Table_Pages[PRINT_TABLE_MAX_PAGES_TO_SHOW];
extern I The_Print_Table_Available_Pages;
extern I The_Print_Table_Current_Page;
extern I The_Print_Table_Rows_Per_Page;
extern I The_Print_Table_Sampled_Row_Count;
extern C The_Clearing_Term_Flag;
extern C The_Last_Expression_Was_Assignment_Flag;
extern C The_Hacky_Reused_A_Mapping_Flag;
extern C The_Debug_OK_Flag;
extern I The_Real_RAM_Memory_Bound;
extern I The_Outstanding_Memory_Counter;
extern C The_Fork_on_Connect_Flag;
extern I The_Fork_on_Connect_Socket;
extern C The_Passed_License_Check_Flag;
extern C The_Process_is_Active_Parent;
extern C The_Process_is_Child_Flag;
extern C The_Process_is_Child_Server_Flag;
extern I The_Process_is_Child_Number;
extern I The_Process_Family_Size;
extern I *The_Process_Created_Registry;
extern I *The_Process_Inherited_Registry;
extern I The_Process_is_at_Depth;
extern I The_Process_Created_Registry_Bytes;
extern C The_Process_Executes_Interleaved;
extern I The_Process_Segment_Starter;
extern I The_Process_Segment_Window;
extern I The_Process_Shm_Handle;
extern I The_Process_Shm_Handles[256];
extern C The_Process_Shm_Name[256];
extern pthread_t The_Socket_HUP_Thread;
extern C The_Thread_Safe_Flag;
extern pthread_mutex_t The_Pool_Mutex;
extern pthread_mutex_t The_Work_Stack_Mutex;
extern pthread_mutex_t The_Disk_Mmap_Mutex;
extern volatile bool kerf_ready;
int kevin_try_stuff();
bool is_foreground_process();
bool is_background_process();
int main(int argc,char **argv);
int try_tests();
int namespace_init();
int cache_init();
int library_init();
int startup_script();
void logfile_init();
bool chatty_environment();
void banner();
int kerf_init();
void kerf_exit(int exit_code);
void kerf_reset(bool wipe_args);
void kerf_atexit();
void cleanup();
K net_kcall(K built);
K json_net_call(K json);
S json_api_call(S string,S arg_in_json,double *inside_time);
K interpret(K snippet);
K _ex(V fake,...);
K call(S string,K args);
K kcall(K snippet,K args);
void init_genrand64(unsigned long long seed);
unsigned long long genrand64_int64(void);
double genrand64_real2(void);
extern I SEED;
void random_init();
I rI();
F rF();
I urandomBits();
void seedPRNG(I s);
K verb_seed_prng(K x);
void shuffle_intvec_in_place(K x);
K verb_rand(K x,K y);
K verb_deal(K x,K y);
void vitter_a(I *a,I n,I N,I j);
void vitter(I *a,I n,I N);
void show_options();
int handle_pre_args(int argc,char **argv);
int handle_args(int argc,char **argv);
int auth_init();
bool is_incomplete(K x);
int system_script_load(S cstring,bool warn_on_missing);
K xload(K x);
int kerf_history_init();
void show_blocks();
void show_stack(VM m);
K show_hex(K k);
K show_full(K x);
K show(K x);
K easy_show(K x);
K last(K x,K y);
void show_float(F f,I last);
void simple_show_error(int val);
K shout_error_map(K x);
K easy_show_error_map(K x);
K shout_dtbucket(K x,I depth);
K easy_show_dtbucket(K x);
K shout_float(F f,I force_decimal);
K pretty_table_add_border_topper(K build,K widths);
K pretty_table_add_border_middle(K build,K widths);
K pretty_table_add_border_bottom(K build,K widths);
volatile K shout_pad(K string,I width,I align,I force_width);
K pretty_table_add_row(K build,K widths,K row,I align,I force_width,I depth,I tick,I escape,I full);
K shout_map(K x,I depth,bool tick,bool escaped,bool full,bool indent);
K shout(K x,I depth,bool tick,bool escaped,bool full,bool indent);
K easy_show2(K x,I tick,I depth,bool escaped);
void print_timing(F elapsed);
K timing(K x);
void _play(S text,S out_prefix,bool timing);
void play(S text);
K rep(K x);
K xout(K x);
K xdisplay(K x);
void try_table_printing_feature();
void reset_table_printing_feature();
void populate_table_printing_feature(K x);
K page_for_table_at_index(K x,I i);
C ensure_has_char(K x,I index);
K ensure_has_arg(K x,I index);
K format_chunk_string(K arg,int width);
K format_chunk_int(K arg,int width,int places);
K format_chunk_float(K arg,int width,int places);
K format(K x,K y);
K extract(K x);
K right(K w,K x,K y,K z);
K cow_sorted_arrays_intervals_tool(K interval,K left,K right,C kind,bool fuzzy,K lowers_dupe);
K sorted_tables_chase(K left,K right,I fuzzy_index);
K join_left(K x,K y,K z);
K join_asof(K left_table,K right_table,K match_keys,K fuzzy_keys);
K placeholder_sql_delete(K target,K where_clauses,K select_clauses,K order_clauses,K limit_clauses);
K cow_table_delete(K table,K where_clauses,K select_clauses,K order_clauses,K limit_clauses);
K placeholder_sql_update(K target,K where_clauses,K groupby_clauses,K select_clauses,K as_clauses,K order_clauses,K limit_clauses);
K junky_table_copy(K table);
K cow_table_update(K table,K where_clauses,K groupby_clauses,K update_clauses,K as_clauses,K order_clauses,K limit_clauses,I groupby_subprefixes);
K placeholder_sql_select(K table,K where_clauses,K groupby_clauses,K select_clauses,K as_clauses,K order_clauses,K limit_clauses);
K _debug_partable_select(K passed,K path);
K atlas_select(K atlas,K where_clauses,K groupby_clauses,K select_clauses,K as_clauses,K order_clauses,K limit_clauses,I groupby_subprefixes);
extern I binning_magic_number;
K single_column_binner(K x,I *bin_count);
void combine_column_bins(K x,K y,K *output,I *bin_count);
K group_by_binner(K x,I *bin_count);
bool gby_hacktivated(K arg);
void whichify(K *x);
K _where_type_combiner(K x,K y);
K potential_column_names_from_functions(K x,bool *has_star);
K table_select(K table,K where_clauses,K groupby_clauses,K select_clauses,K as_clauses,K order_clauses,K limit_clauses,I groupby_subprefixes,K groupby_bins,I groupby_bin_count);
K tableize(K parent,K payload,K clause_text,K inferred_name,K as_name);
K placeholder_sql_insert(K target,K columns,K values,K conflict_keys);
K cow_atlas_insert(K atlas,K columns,K values);
K cow_table_insert(K table,K columns,K values,K conflict_keys);
void translate_sql(K tree,K *bytecode,K *debug,K function,K parent);
void translate_sql_insert(K tree,K *bytecode,K *debug,K function,K parent);
void translate_sql_columns(K tree,K *bytecode,K *debug,K function,K parent);
void translate_sql_paren(K tree,K *bytecode,K *debug,K function,K parent);
void translate_sql_select(K tree,K *bytecode,K *debug,K function,K parent);
K sql_parse_map_from_tree(K tree);
void translate_sql_wheres(K parse_map,K *bytecode,K *debug,K function,K parent);
void translate_sql_groupbys(K parse_map,K *bytecode,K *debug,K function,K parent);
void translate_sql_delete(K tree,K *bytecode,K *debug,K function,K parent);
void translate_sql_update(K tree,K *bytecode,K *debug,K function,K parent);
I time_fraction_consumer(const char *s,I n);
I nanos_xstrptime(const char *s,const char *format);
struct tm tm_from_date_define();
void expires_binarys_date();
bool license_at_path_is_good(S license_path);
void expires_license_file();
void expires();
I DATE_ONLY(I stamp);
I TIME_ONLY(I stamp);
I NOW_DATE_ONLY();
I NOW_TIME_ONLY();
I NOW_STAMP();
K now(K x);
K now_date(K x);
K now_time(K x);
K stamp_diff(K x,K y);
ALWAYS_INLINE I int_for_TM_NANOS_and_code(TM_NANOS t,C code);
K array_thing_bucket_nanos(I *table,K dtbucket,TM_NANOS abs_tm,bool swap);
char week_of_year_from_TM_NANOS(TM_NANOS t);
TM_NANOS TM_NANOS_from_dtbucket_and_initializer(K x,TM_NANOS i);
TM_NANOS TM_NANOS_from_stampI(I i,bool local);
TM_NANOS TM_NANOS_from_stamp(K x,bool local);
TM_NANOS TM_NANOS_for_unit(C unit,I i);
TM_NANOS TM_NANOS_affine(TM_NANOS x,C unit,I interval,I multiple);
TM_NANOS TM_NANOS_sum(TM_NANOS x,TM_NANOS y);
TM_NANOS TM_NANOS_from_tm(void *s);
I stampI_from_tm(void *s,bool local);
I stampI_from_TM_NANOS(TM_NANOS x,bool local);
I time_format_chunk(S fbuf,I dst,F seconds_frac,S fmt);
stampbuf time_format(K x,bool local,S format);
stampbuf time_from_stamp(K x,bool local,int decimal_places,I no_rollover);
stampbuf date_from_stamp(K x,bool local);
stampbuf datetime_from_stamp(K x,bool local,int decimal_places);
bool has_date_only(K x);
bool has_time_only(K x);
K format_stamp(K x,K y);
S parse_stamp_ns(F *fraction,S source,I digits);
S parse_stamp_chunk(struct tm *sofar,F *fraction,S source,C token);
K parse_stamp(K x,K y);
stampbuf buf_from_stamp(K x,bool local,int decimal_places);
K parse_absolute_date(K x,bool local);
K parse_absolute_time(K x,bool local);
K parse_absolute_datetime(K x,bool local);
K parse_relative_datetime(K x,bool local);
void bars_update_bucket_bin_search(I left_multiple,I right_multiple,TM_NANOS *left_bucket,TM_NANOS *right_bucket,I *left_stamp,I *right_stamp,I target_stamp,C units_code,I units_interval,bool local);
void bars_update_bounding_buckets_for_stamp(TM_NANOS *left_bucket,TM_NANOS *right_bucket,I *left_stamp,I *right_stamp,I target_stamp,C units_code,I units_interval,bool local);
K bars(K x,K y,K z);
ALWAYS_INLINE K bar_subsecond_modular_with_divisor(K x,I divisor);
ALWAYS_INLINE K bar_modular_time_index_by_unit_code(K x,C code);
int time_go();
K new_atlas();
K new_atlas_from_K(K x);
bool is_special_atlas_form(K x);
ALWAYS_INLINE I atlas_count_keys_in_map_for_index(K x,I k);
K atlas_preserving_integral_at(K x,K y);
K atlas_destroying_integral_at(K x,K y);
K cow_atlas_add(K x,K y);
K deraze_map(K x);
K raze_map(K x);
K atlas_at_string(K atlas,K string);
K atlas_map_at_index(K x,I k);
I atlas_index_from_key_index(K x,I i);
K atlas_indices_from_key_indices(K x,K y);
int atlas_go();
K meta_table(K x);
K new_table_x();
K same_table_but_empty_columns(K table);
K cow_table_join_tuple(K x,K y);
K cow_table_mesh(K x,K y,bool fill);
K cow_table_add(K x,K y);
K cow_table_set_column_attributes(K table,K column_name,C attributes);
K cow_table_bitwise_or_column_attributes(K table,K column_name,C attributes);
C table_column_attributes(K table,K column_name);
C table_column_has_attributes(K table,K column_name,C attributes);
K table_trait_get_column(K table,K column_name);
K cow_table_trait_set_column(K table,K column_name,K payload);
bool table_column_is_key(K table,K column_name);
bool table_column_is_key_or_fkey(K table,K column_name);
bool table_keys_in_other_table(K haystack,K needle);
bool tables_match_on_keys(K x,K y);
I table_count_keys(K x);
K table_keyed_columns_list(K x);
K table_cast_from_map(K x);
bool table_has_column(K table,K column_name);
K cow_table_add_column_uncollided(K table,K column_name,K column_values);
K cow_table_add_column(K table,K column_name,K column_values);
K cow_table_add_column_uncollided_empty(K table,K column_name);
K alpha_column_name(K name);
K uncollided_name(K table,K column_name);
K alpha_uncollided_name(K table,K name);
K cow_table_receive_column_from_table(K destination,K origin,K column_name,bool rename_collisions);
K table_ordered_subtable_on_column_keys(K table,K keys);
K table_column_default_value(K table,K column_name);
K default_column_entry_for_type(K x);
I table_columns(K table);
I table_rows(K table);
bool table_ragged(K table);
K table_row_as_vlist(K table,I row);
K cow_table_rename_column(K table,K old_name,K revised_name);
void cow_table_drop_column();
K sample_map_from_table(K x);
K practice_table_1();
K practice_table_2();
int table_fun();
int table_go();
extern K The_Test_Kerf_Tree_Saver;
extern I The_Test_Cases_Count;
extern I The_Test_Cases_Passed_Count;
extern I The_Test_Cases_Failed_Count;
extern I The_Test_Cases_Skipped_Count;
extern F The_Test_Start_Time;
void test_suite_initialize();
void test_suite_finalize();
void test_case_buildup();
void test_case_teardown();
void test_case_handle_result(bool ok);
C test_equal(S a,S b);
void test_allocations();
K test_incorrect_sort_attr(K x);
I container_insane(K x);
I di(K x,I verbose);
void run_tests();
extern ATOMIZE0 NONE_D;
extern ATOMIZE0 ATOMICA;
extern ATOMIZE0 ATOMICB;
extern ATOMIZE0 AGGR_A;
extern ATOMIZE0 LAZYDEV;
extern TYPE0 NO_T;
extern TYPE0 ALL_T;
extern TYPE0 CHAR_T;
extern TYPE0 INT_T;
extern TYPE0 NUMERIC;
extern TYPE0 NUMERIC2;
extern TYPE0 NUM_TIME;
extern TYPE0 NUMTIME2;
extern TYPE0 MAP_T;
extern TYPE0 TABLE_T;
extern VERB VERB_DISPATCH[];
extern ADVERB ADVERB_DISPATCH[];
int verb_init();
extern I VERB_PLUS_ID;
extern VERB VERB_PLUS;
extern I VERB_NEGATE_ID;
extern VERB VERB_NEGATE;
extern I VERB_OR_ID;
extern VERB VERB_OR;
extern I VERB_AND_ID;
extern VERB VERB_AND;
void reserved_verbs_init();
void reserved_adverbs_init();
void lookup_verb_data_via_token(K token,I *verb_code,VERB *verb,bool has_adverb,I apply,I argc);
I lookup_verb_id_by_name_or_sym(S x);
I lookup_adverb(K payload);
K ply(K w,K x,K y,K z,I argc,VERB op);
K ident(K w,K x,K y,K z);
K equals(K x,K y);
K less(K x,K y);
K greater(K x,K y);
K lesseq(K x,K y);
K greatereq(K x,K y);
K noteq(K x,K y);
K equals_pre(K x,K y);
K less_pre(K x,K y);
K greater_pre(K x,K y);
K lesseq_pre(K x,K y);
K greatereq_pre(K x,K y);
K noteq_pre(K x,K y);
K between_pre(K x,K y);
K between(K x,K y);
K xin_pre_whered(K x,K y);
K xin(K x,K y);
K xexcept(K x,K y);
K xunion(K x,K y);
K xintersect(K x,K y);
K verb_powerset(K x);
K cow_next_perm(K x);
K verb_perms(K x,K w);
K verb_combs(K x,K y,K z);
K xsqrt(K x);
K xln(K x);
K xlog10(K x);
K xlog2(K x);
K xsin(K x);
K xcos(K x);
K xtan(K x);
K xasin(K x);
K xacos(K x);
K xatan(K x);
K xsinh(K x);
K xcosh(K x);
K xtanh(K x);
K xerf(K x);
K xerfc(K x);
K monadic_math(K x,F(*passed_function)(F),bool monotonic_increasing);
K xfloor(K x);
K xceil(K x);
K xabs(K x);
K xlog(K w,K x);
K xlg(K x);
K msum(K x,K y);
K mcount(K x,K y);
K mavg(K x,K y);
K mmax(K x,K y);
K mmin(K x,K y);
K plus(K x,K y);
K plus_rel_time(K x,K y);
K minus(K x,K y);
K minus_rel_time(volatile K x,volatile K y);
K xsum(K x,K y);
K rsum(K x,K y);
K xmin(K x,K y);
K xmax(K x,K y);
K maxback(K x,K y);
K minback(K x,K y);
K xavg(K x);
K xstd(K x);
K _debug_gby(K x);
K xvar(K x);
K verb_median(K x);
K xtimes(K x,K y);
K negate(K x);
K max_or(K x,K y);
K min_and(K x,K y);
K xnot(K x);
K divide(K x,K y);
K xmod(K x,K y);
K xexp(K x,K y);
K xrank(K x,K y);
K xor(K x,K y);
K transpose(K x);
K dotp(K x,K y);
K mmul(K x,K y);
K minv(K x);
K lsq(K b,K a);
I lenI(K x);
K atom(K x);
K match(K x,K y);
K monad_eval(K x);
K join(K x,K y);
K verb_cross(K x,K y);
K enumer(K x);
K hashed(K x);
K atlased(K x);
K indexed(K x);
K distinct(K x);
K xsort(K x);
K xshuffle(K x);
K order(K x);
K part_hash(K x);
K crossover(K x);
K part_intvec(K x);
K part(K x);
K til(K x);
K py_range(K w,K x,K y);
K xshift(K x,K y,K z);
K xisnull(K x,K y);
K enlist(K x);
K take(K x,K y);
K explode(K x,K y);
K implode(K x,K y);
K count_null(K x);
K count_nonnull(K x);
K car(K x);
K xcar(K x,K y);
K xcdr(K x);
K flatten(K x,K y);
K repeat(K x,K y);
I INTIFY(K x);
F FLOATIFY(K x);
K parse_int(K x,K y);
K parse_float(K x);
K int_cast(K x);
K float_cast(K x);
K char_cast(K x);
K stamp_cast(K x);
K string_cast_I(I i);
K string_cast_F(F f,I points,I c);
K string_cast_D(K x,bool local,int decimal_places);
K string_cast(K x);
K trim(K x);
K emu_debug_mode(K x);
K reserved_verb(K x);
K xsleep(K x);
K xexit(K x);
K verb_reset(K x);
K xobj_keys(K x);
K xobj_values(K x);
K xmap(K w,K x);
K xtable(K x,K y);
K stronger_decoder(K x,K y,K column_decoder);
K decode_columns(K x,K y);
K xkerf_type(K x);
K xhash(K x);
S kerf_type_name_cstring_from_char(C c);
K xkerf_type_name(K x);
K xtables(K x);
K xdelete(K x,K y);
K xhas_column(K x,K y);
K xhas_key(K x,K y);
K xsystem(K x);
K xshell(K x);
K sort_debug(K x);
K xmkdir(K x);
K verb_split(K x,K y);
K verb_ngram(K x,K y);
K verb_search(K x,K y);
K verb_filter(K f,K x);
K verb_help(K x);
I open_file_handle(S path,bool create);
int temphandle();
bool file_exists_valid(S path);
bool file_path_is_directory(S path);
bool file_handle_is_directory(I handle);
bool file_handles_valid_match(int fd1,int fd2);
K pointer_for_mapped_file_via_synonymous_handle(int fd);
unsigned int device_major_for_file_handle(int fd);
extern K DISK_MMAP_POINTER_REGISTRY;
void disk_mmap_registry_add_entry(K mapOrigin,I mapSizeBytes,I handle,I fileSize,I isPrivate);
void *disk_mmap_registry_find_mapped_origin(V v);
K disk_mmap_registry_find_entry_by_pointer_in_mapped_range(V v);
void disk_mmap_registry_remove_entry_for_mapped_origin_pointer(K x);
void disk_flush_mmap_caches_via_registry();
K disk_map_handle_shared(I f);
K disk_map_handle_shared_maybe_flat(I f,K starting_value,bool flat_file);
I handle_expander(I requested_bytes,I handle);
I handle_truncate(I requested_bytes,I handle);
I sendall(I socket_fd,S buffer,I length);
I brute_write(V buf,I count,I h,I socket,FILE *file,V *memory);
I brute_write_empty(I count,I h,I socket,FILE *file,V *memory,bool force_write_empty_bytes);
I wire_size_K(K x);
I write_k_to_handle(K x,I h,C zip_type);
I write_k_to_handle_options(K object,I h,C zip_type,C execution_type,C response_type,C display_type);
K0 header_to_network_order(K0 r);
I write_k_helper(K x,I handle,I useNetworkOrder,I depth,I socket,FILE *file,V *memory,bool force_write_empty_bytes);
I read_disk_k_from_handle_to_membuf_of_known_good_size(V x,I h);
K read_k_from_handle(K x,I h);
I lineage_index(K x,K y);
I populate_growth_tracking(K x,K y,I m_requested,V pointers[],C revised_ems[],I depth);
K _expand_disk_nest_special(K x,I indexes_needed,I revised_payload_used,I zero_new);
K _expand_disk_backed(K x,I m_requested,I zero_new);
I _disk_roll(K mmap_registry_entry,I delta);
K expand_disk_double_offspring_over_half_capacity(K x);
void *copy_thread(void *arg);
char copy_from_k_to_good_disk_membuf_temp(V x,K y);
K disk_map_anonymous_shared();
K disk_map_file_shared(S path);
K disk_map_file_shared_maybe_flat(S path,K starting_value,bool flat_file);
char write_k_to_path(K x,S path);
K read_k_from_path(S path);
K write_text(K filename,K text);
int scandir_filter(const struct dirent *e);
K dir_list_k(K w,K x);
K dir_list_s(S path,bool path_prepended,bool skip_hidden);
K open_dir_object(S path);
K open_dir_object_slow(S path);
bool kerf_mkdir(S dirpath,bool fail_on_exist);
int recursive_delete_K(K path);
int recursive_delete(S path);
K write_dir_object(K x,S path);
void _write_dir_object(K x,S path);
K read_parceled_from_path(K x);
K read_striped_from_path(K x);
K write_striped_to_path(K x,K y);
int drive_go();
K new_from_json(K x);
K new_json_from(K x);
bool strict_json_compatible_key(K x);
escapebuf escapebuf_for_char(C c);
K cow_json_append(K string,K object);
int xml_go();
I populated_fields(K x);
bool skipfield(C field);
K new_empty_list_for_fixed_field(C field);
K new_empty_list_for_delimited_field(C field);
ALWAYS_INLINE void sv_callback_column(S string,I length,SV_DATA *data);
ALWAYS_INLINE void sv_callback_row(SV_DATA *data);
ALWAYS_INLINE void sv_callback_column_pre_read(S string,I length,SV_DATA *data);
ALWAYS_INLINE void sv_callback_row_pre_read(SV_DATA *data);
K read_table_from_tsv(K tsv_filename,K fields_k,K header_rows);
K read_table_from_csv(K csv_filename,K fields_k,K header_rows);
K create_table_from_csv(K table_filename,K csv_filename,K fields_k,K header_rows);
K create_table_from_tsv(K table_filename,K tsv_filename,K fields_k,K header_rows);
K create_table_from_psv(K table_filename,K csv_filename,K fields_k,K header_rows);
K append_table_from_csv(K table_filename,K csv_filename,K fields_k,K header_rows);
K append_table_from_tsv(K table_filename,K tsv_filename,K fields_k,K header_rows);
K append_table_from_psv(K table_filename,K csv_filename,K fields_k,K header_rows);
K create_table_from_delimited_file(K table_filename,K delimiter_k,K delimited_filename,K fields_k,K header_rows);
K append_table_from_delimited_file(K table_filename,K delimiter_k,K delimited_filename,K fields_k,K header_rows);
K read_table_from_delimited_file(K delimiter_k,K delimited_filename,K fields_k,K header_rows);
extern SV_DATA *global_sv_data;
K cow_build_table_from_delimited_file(K table,K filename,C separator,K fields_k,I header_rows,bool header_titles,bool in_memory);
void *parser_thread(void *arg);
K _debug_sv(K temp_table_p,K table_p,K index_k,K fields_chars_k_p);
void parser_converter_thing(K null_delimited_charvec,C field,K table,I col_index,SV_DATA *data);
bool string_requires_delimiter_quoting_escaping(K x,C delimiter);
K delimiter_string(K x,C delimiter);
K write_delimited_file_from_table(K delimiter_k,K delimited_filename,K table);
K write_csv_from_table(K csv_filename,K table);
K lines(K filename,K limitation);
K create_table_from_fixed_file(K table_filename,K fixed_filename,K maptributes);
K append_table_from_fixed_file(K table_filename,K fixed_filename,K maptributes);
K read_table_from_fixed_file(K fixed_filename,K maptributes);
K cow_build_table_from_fixed_file(K table,K filename,K maptributes);
K read_from_path(K x);
K write_to_path(K x,K y);
K verb_open_table(K x);
K open_table(K x,K fields,C fields_kind);
extern C sv_char_classes[256];
C sv_char_class_for_char(C c);
extern S SV_STATE_STRING;
extern C sv_transitions[MAX_SV_TRANSITIONS];
extern S SV_ACTION_STRING;
extern C sv_actions[MAX_SV_TRANSITIONS];
void do_sv();
void sv_init_for_separator(C separator);
K cow_sv_unescape_charvec(K x);
K _sv_unescape_charvec(K x);
I _sv_memcpy_skipping_escapes(S d,S s,I n);
void sv_read(S source,I length,SV_DATA *data);
void sv_pre_read(S source,I length,SV_DATA *data);
extern V zip_algos_compress[ZIP_TYPES_MAX];
extern V zip_algos_decompress[ZIP_TYPES_MAX];
void delta_delta_I_transform_chunk(char *source,I sourcelen,bool inverting);
void byte_transform_chunk(char *source,I sourcelen,I itemwidth,bool inverting);
char *zip_algo_compress_chunk_identity(char *source,I chunk_size,I *wrote);
char *zip_algo_compress_chunk_wkdm(char *source,I chunk_size,I *wrote);
char *zip_algo_compress_chunk_gzip_16K(char *source,I chunk_size,I *wrote);
char *zip_algo_compress_chunk_lz4(char *source,I chunk_size,I *wrote);
char *zip_algo_decompress_blob_identity(char *source,I width,bool just_copy_unchanged);
char *zip_algo_decompress_blob_wkdm(char *source,I width,bool just_copy_unchanged);
char *zip_algo_decompress_blob_gzip_16K(char *source,I width,bool just_copy_unchanged);
char *zip_algo_decompress_blob_lz4(char *source,I width,bool just_copy_unchanged);
K compressed(K x,K type);
I compression_bytes_if_decompressed(K x);
I compression_bytes_zipped_up_to(K x);
I compression_bytes_count_currently_uncompressed(K x);
K cow_zip_maybe_compress(K x);
K cow_zip_add_bytes(K x,char *bytes,I length);
K cow_zip_add(K x,K y);
I2 compression_range_for_compressed_chunk_index(K x,I p);
C *compression_decompressed_chunk_by_index(K x,I p,bool skip_cache);
K zip_with_options(K x,K *char_vector,K *index_vector);
K new_unzipped_charvec_temp(K x);
K new_zipped_charvec_temp(K x);
extern I pages;
extern K zipg;
K zip(K x);
int zip_go();
extern const char hashLookupTable[];
extern const char hashLookupTable[];
void WKdm_decompress(uint32_t *src_buf,uint32_t *dest_buf,uint32_t words);
void WKdm_decompress(uint32_t *src_buf,uint32_t *dest_buf,uint32_t words);
uint32_t WKdm_compress(uint32_t *src_buf,uint32_t *dest_buf,uint32_t num_input_words);
uint32_t WKdm_compress(uint32_t *src_buf,uint32_t *dest_buf,uint32_t num_input_words);
#define INTERFACE 0
#define EXPORT_INTERFACE 0
#define LOCAL_INTERFACE 0
#define EXPORT
#define LOCAL static
#define PUBLIC
#define PRIVATE
#define PROTECTED
